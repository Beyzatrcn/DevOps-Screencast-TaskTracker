# DevOps Screencast â€“ TaskTracker

Dieses Mini-Projekt wurde im Rahmen des Moduls DevOps entwickelt und dient als praktisches Beispiel zur Anwendung von Build-Tools, Versionskontrolle, automatisierten Tests und moderner Softwareentwicklung mit Spring Boot.

## ğŸ¯ Ziel des Projekts

Ziel dieses Projekts war es, ein einfaches, aber praxisnahes Tool zu erstellen, das typische DevOps-Prinzipien wie Automatisierung, Versionierung, Testbarkeit und Wiederholbarkeit demonstriert. Besonders wichtig war es, den Unterschied zwischen manuellen Tests (z.â€¯B. in Postman) und automatisierten Unit-Tests greifbar zu machen und beide Methoden sinnvoll im Projekt einzusetzen.

Die Anwendung besteht aus einem Java/Spring Boot Backend und einem einfachen HTML/JavaScript-Frontend. Durch diese Trennung lÃ¤sst sich das Frontend unabhÃ¤ngig vom Backend entwickeln und testen.

Dies ist ein einfaches Projektmanagement-Tool (Mini-Aufgabenliste), das im Rahmen des DevOps-Lernjournals erstellt wurde.

## ğŸ› ï¸ Technologien

- Java 21
- Spring Boot 3.3.5
- Gradle 8.10.2
- Postman (fÃ¼r API-Tests)
- Git (lokal)

Die ausgewÃ¤hlten Technologien bilden die Grundlage fÃ¼r eine moderne Backend-Entwicklung:
- Java 21 ist eine aktuelle LTS-Version, die moderne Sprachfeatures bietet.
- Spring Boot 3.3.5 ermÃ¶glicht schnelles Setup und einfache Konfiguration von REST-Services.
- Gradle 8.10.2 dient als Build-Tool fÃ¼r das Kompilieren, Testen und Packen der Anwendung.
- Postman wird fÃ¼r manuelle Tests der REST-API genutzt.
- Git sorgt fÃ¼r nachvollziehbare Versionshistorie und ermÃ¶glicht kollaboratives Arbeiten.

---

## âœ… Implementierte Funktionen

UrsprÃ¼nglich war geplant, das Projekt nach dem Prinzip des **Test-Driven Development (TDD)** umzusetzen. Aufgrund von technischen und zeitlichen Herausforderungen wurde jedoch entschieden, zunÃ¤chst die FunktionalitÃ¤t direkt zu implementieren und anschliessend zu testen.

Der Entwicklungsprozess orientierte sich an den Prinzipien von DevOps, wobei sowohl Automatisierung als auch kontinuierliches Testen eine zentrale Rolle spielten.

---

### 1ï¸âƒ£ Test schreiben

Bevor die eigentliche FunktionalitÃ¤t programmiert wurde, wurde ein automatisierter Test erstellt, um das gewÃ¼nschte Verhalten zu definieren.

Dieser erste Test wurde bewusst vor der eigentlichen Implementierung geschrieben, um das gewÃ¼nschte Verhalten des Systems festzulegen. Dies entspricht der TDD-Idee, dass Anforderungen in Form von Tests formuliert werden.

- Ziel: Sicherstellen, dass eine neue Aufgabe Ã¼ber `POST /tasks` erstellt und mit `GET /tasks` abgerufen werden kann.
- Testname: `testPostAndGetTasks()`
- Speicherort: `src/test/java/ch/zhaw/iwi/devops/task/TaskControllerTest.java`

âœ… Testdurchlauf erfolgreich:

![Test erfolgreich](Screenshots/testPostAndGetTasks()_PASS.png)

---

### 2ï¸âƒ£ Implementierung

Die FunktionalitÃ¤t wurde in folgenden Klassen umgesetzt:

- `Task.java`: Datenmodell mit Feldern `name` und `status`
- `TaskController.java`: REST-Controller mit Endpunkten fÃ¼r POST und GET

Die Entscheidung, von TDD abzuweichen und zuerst funktionale Endpunkte zu implementieren, beruhte auf praktischen Herausforderungen, wie z.â€¯B. der initial fehlenden Teststruktur und Problemen mit der Testkonfiguration unter Spring Boot 3.

---

### 3ï¸âƒ£ Refactoring

Nachdem die Funktionen erfolgreich getestet wurden, wurde der Code strukturell verbessert und dokumentiert. Der Test ist weiterhin automatisiert Ã¼ber `./gradlew test` aufrufbar.

Dabei wurde darauf geachtet, dass die FunktionalitÃ¤t erhalten bleibt, wÃ¤hrend der Code Ã¼bersichtlicher und wartbarer wird. Die Tests dienen weiterhin als Sicherheitsnetz bei kÃ¼nftigen Ã„nderungen.

---

## ğŸ¤– Warum automatisierte Tests?

Automatisierte Tests wurden eingesetzt, um die KernfunktionalitÃ¤t des Task-Trackers zuverlÃ¤ssig und wiederholbar zu Ã¼berprÃ¼fen. Im Vergleich zu manuellen Tests mit Postman bieten automatisierte Tests folgende Vorteile:

- âœ… **Wiederholbarkeit**: Einmal geschriebene Tests lassen sich beliebig oft ausfÃ¼hren â€“ auch nach CodeÃ¤nderungen.
- â±ï¸ **Zeitersparnis**: Kein manuelles Ã–ffnen von Postman oder Eintippen von JSON-Daten nÃ¶tig.
- ğŸ§© **FrÃ¼hzeitige Fehlererkennung**: Ã„nderungen am Code fÃ¼hren bei Bedarf direkt zu TestfehlschlÃ¤gen.
- ğŸ§ª **Integration in CI/CD-Pipelines**: Tests kÃ¶nnen automatisch bei jedem Git-Push oder Deployment ausgefÃ¼hrt werden.

AuÃŸerdem lassen sich durch automatisierte Tests Szenarien abbilden, die in Postman nur mÃ¼hsam simuliert werden kÃ¶nnen â€“ z.â€¯B. mehrere aufeinanderfolgende API-Aufrufe mit Zwischenvergleichen oder komplexe Assertions. Diese Testlogik ist im Testcode wesentlich besser wartbar und dokumentiert.

### Getestetes Verhalten

Der automatisierte Test `testPostAndGetTasks()` prÃ¼ft folgendes:

1. Eine neue Aufgabe mit einem bestimmten Namen und Status wird per `POST /tasks` erstellt.
2. Dieselbe Aufgabe wird anschliessend Ã¼ber `GET /tasks` wiedergefunden.
3. Der Name und der Status stimmen mit den erwarteten Werten Ã¼berein.

Der Test deckt damit sowohl die Erstellung als auch die Konsistenz der gespeicherten Daten ab â€“ ein wichtiger Aspekt zur Sicherstellung der API-FunktionalitÃ¤t.

## ğŸ§ª Manuelle Tests mit Postman

Neben automatisierten Tests wurde die API auch manuell Ã¼ber **Postman** getestet.

Manuelle Tests waren insbesondere in der Anfangsphase hilfreich, um die API-Endpunkte zu Ã¼berprÃ¼fen, bevor automatisierte Tests stabil liefen. Auch zum Debugging bei TestfehlschlÃ¤gen bietet Postman eine gute visuelle UnterstÃ¼tzung.

### ğŸ”¹ POST `/tasks`

- Erstellt eine neue Aufgabe
- Beispielanfrage:
  ```json
  {
    "name": "Erste Aufgabe",
    "status": "Offen"
  }
  ```

![Beispiel POST](Screenshots/1_Beispiel_Test_fuÌˆr POST.png)

---

### ğŸ”¹ GET `/tasks`

- Gibt alle erstellten Aufgaben als JSON-Array zurÃ¼ck.

![Beispiel GET](Screenshots/2_Beispiel_Test_fuÌˆr_GET.png)

---

## âš ï¸ Herausforderungen beim Testen

WÃ¤hrend der Entwicklung traten mehrere Herausforderungen auf:
- Die erste Version des Tests konnte nicht ausgefÃ¼hrt werden, da der Server-Port bereits von einer anderen Instanz belegt war.
- Das Umsetzen eines echten TDD-Prozesses gestaltete sich schwierig, da Spring Boot 3 und Java 21 einige zusÃ¤tzliche Konfigurationsschritte (z.â€¯B. Preview Features, Annotationen) erforderlich machten.
- Ein Test scheiterte zunÃ¤chst, da `LocalServerPort` nicht korrekt importiert oder unterstÃ¼tzt wurde.

Diese Probleme konnten jedoch nach und nach identifiziert und gelÃ¶st werden. Sie zeigen, wie wichtig eine funktionierende Testumgebung ist und wie nÃ¼tzlich automatisierte Tests zur Fehlersuche sind.

---

## ğŸ§© Weiterentwicklung

Als nÃ¤chster Schritt wurde ein separates Frontend in einem eigenen Ordner `frontend` erstellt. Dieses besteht aus einer einfachen `index.html`, die per JavaScript Aufgaben anzeigt und hinzufÃ¼gt. So kÃ¶nnen Benutzer:innen die Anwendung direkt im Browser testen â€“ ohne Postman oder Terminal.

Weitere geplante Features:
- Aufgabenstatus Ã¤ndern
- Aufgaben lÃ¶schen
- Validierung und Fehlermeldungen im Frontend
- CSS zur besseren Darstellung

---

## ğŸ”— GitHub Repository

â¡ï¸ [DevOps-Screencast-TaskTracker](https://github.com/Beyzatrcn/DevOps-Screencast-TaskTracker.git)

---

## ğŸŒ BenutzeroberflÃ¤che (Frontend)

Um die Nutzung der REST-API ohne Tools wie Postman zu erleichtern, wurde ein einfaches Frontend entwickelt. Es befindet sich im Ordner `frontend/` und besteht aus einer HTML-Datei mit eingebettetem JavaScript.

### ğŸ”¹ Funktionen

Das Frontend ermÃ¶glicht:
- die Eingabe von Aufgabenname und Status,
- das Absenden neuer Aufgaben an das Backend (`POST /tasks`),
- das Laden und Anzeigen aller gespeicherten Aufgaben (`GET /tasks`).

Benutzer:innen kÃ¶nnen damit die Anwendung direkt im Browser testen.

### ğŸ–¼ï¸ Screenshot

![Task Tracker Frontend](Screenshots/Frontend_1.png)

### ğŸ”§ Voraussetzungen

- Das Spring Boot Backend muss lokal unter `http://localhost:8080` laufen.
- Der Browser greift Ã¼ber `file:///` auf die `frontend/index.html` zu.

### ğŸ’¡ Vorteile des Frontends

- Keine Installation zusÃ¤tzlicher Tools notwendig (z.â€¯B. Postman).
- Bessere Benutzererfahrung beim Testen der REST-API.
- Schnellere RÃ¼ckmeldung bei der Eingabe von Aufgaben.

---